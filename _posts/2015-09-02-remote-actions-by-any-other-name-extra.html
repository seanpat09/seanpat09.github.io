---
layout: post
title: 'Remote Actions By Any Other Name (Extra Credit: local development?)'
date: '2015-09-02T16:03:00.001-07:00'
author: Sean Cuevo
tags:
- namespacing
- local development
- namespace
- javascript
- salesforce
modified_time: '2015-09-02T16:19:06.410-07:00'
blogger_id: tag:blogger.com,1999:blog-4727318240760747618.post-6698867959352628180
blogger_orig_url: http://www.socalledprogrammer.com/2015/09/remote-actions-by-any-other-name-extra.html
---

<article class="markdown-body">
    <p>While working on a managed package with several developers, dealing with the namespace can be really annoying. Developers (ideally) would not be developing directly in the packaging org, so your team won't have access to the namespace and they'll find themselves trying to figure out how to program more dynamically without hard references to the namespace. This sounds like a good thing, but in practice it can lead to some poor implementation choices, especially when working with Javascript and Remote Actions.</p>
    <!--break-->
    <h2><a id="user-content-flawed-dynamic-namespacing" class="anchor" href="#flawed-dynamic-namespacing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Flawed Dynamic Namespacing</h2>
    <p>Salesforce recommends using the {!$RemoteAction} merge field to deal with namespacing. For example, your code might look like this:</p> <pre><code>    Visualforce.remoting.Manager.invokeAction(<br />        '{!$RemoteAction.MyController.doTheThing}',<br />        function(result, event) {<br />          if (event.status) {<br />            handleSuccess();<br />          } else {<br />            handleRejection(event);<br />          }<br />        }<br />    );<br /></code></pre>
    <p>This works great because you don't have to worry about the namespace at all. This code will work in your separate developer org as well as the packaging org. However, since static resources don't support merge fields this has to be done within the Visual Force page inside a script block. It's not a huge deal, but you do lose the benefit of the static resources caching plus it makes your Visual Force page messier.</p>
    <h2><a id="user-content-stick-it-in-an-object" class="anchor" href="#stick-it-in-an-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>Stick it in an object</h2>
    <p>Instead just stick your namespaced controller in another variable:</p> <pre><code>(function(){<br />    'use strict';<br />    var SFDCCtrl = MyNamespace ? MyNamespace.myController : myController<br /><br />    function myRemoteCall(){<br />        SFDCCtrl.doTheThing( function(result, event){<br />            if (event.status) {<br />              handleSuccess();<br />            } else {<br />              handleRejection(event);<br />            }<br />        });<br />    }<br />}());<br /></code></pre>
    <p>In your Visual Force page Salesforce creates global object named after your controller that contains all of your remote actions. If that controller is namespaced, it just wraps that object in an object named after your namespace:</p> <pre><code>//Namespaced Controller<br />var MyNamespace = {<br />    MyController : {<br />        doTheThing : function(){};<br />    }<br />}<br /><br />//Non-namespaced controller<br />var MyController =  {<br />    doTheThing : function(){};<br />}<br /></code></pre>
    <p>Now you can stick your javascript in a static resource without having to worry about it working in namespace and non-namespaced orgs.</p>
    <h3><a id="user-content-extra-credit-possible-local-development" class="anchor" href="#extra-credit-possible-local-development" aria-hidden="true"><span class="octicon octicon-link"></span></a>Extra Credit: Possible Local Development?</h3>
    <p>Local development is like the holy grail of Salesforce programming. I don't think we'll ever have full-fledged local development, but when it comes to building Javascript heavy pages there might be some hope. Here's how I would do the namespacing with Angular:</p> <pre><code>//SFDCCtrl.js<br />(function () {<br />    'use strict';<br />    angular.module('myModule')<br />        .service('SFDCCtrl', SFDCCtrl );<br />        function SFDCCtrl(){<br />            this.MyController = MyNamespace ? MyNamespace.MyController : MyController;<br />        }<br />})();<br /></code></pre> <pre><code>//AController.js<br />(function () {<br />    'use strict';<br />    angular.module('myModule')<br />        .controller('AController', AController );<br />        AController.$inject = ['SFDCCtrl'];<br />        function AController(SFDCCtrl){<br />            function myRemoteCall(){<br />                SFDCCtrl.MyController.doTheThing( function(result, event){<br />                    if (event.status) {<br />                      $scope.theThing = result;<br />                    } else {<br />                      handleRejection(event);<br />                    }<br />                });<br />            }<br />        }<br />})();<br /><br /></code></pre>
    <p>With the angular example, since your controller is tucked away nicely in its own service, you easily mock your SFDC controller with your tests. But why stop there? Why not mock it for development so you can work locally? With Javascript frameworks like Angular and React, I find myself using less Visual Force, simply using the controller for interactions with the database. This can be frustrating because you know that a majority of your page could be compiled on your machine, but you have to hit the server on every save, which can take several minutes for each request! Take the following super simple example that uses the above angular example:</p> <pre><code>//MyPage.page<br />&lt;apex:page controller="MyController" applyBodyTag="false"&gt;<br />    &lt;body app="myModule"&gt;<br />        &lt;div ng-controller="AController"&gt;<br />            {{ "{{" }}theThing}}<br />        &lt;/div&gt;<br />    &lt;/body&gt;<br />    &lt;script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.2/angular.min.js"&gt;&lt;/script&gt;<br />    &lt;script src="{!URLFOR($Resource.myAngularApp,'SFDCCtrl.js')}"/&gt;<br />    &lt;script src="{!URLFOR($Resource.myAngularApp,'AController.js')}"/&gt;<br />&lt;/apex:page&gt;<br /><br /></code></pre>
    <p>This is basically just a regular html/js page wrapped in visualforce (with a few merge field changes):</p> <pre><code>&lt;html&gt;<br />    &lt;body app="myModule"&gt;<br />        &lt;div ng-controller="AController"&gt;<br />            {{ "{{" }}theThing}}<br />        &lt;/div&gt;<br />    &lt;/body&gt;<br />    &lt;script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.2/angular.min.js"&gt;&lt;/script&gt;<br />    &lt;script src="SFDCCtrl.js'"/&gt;<br />    &lt;script src="AController.js'"/&gt;<br />&lt;/html&gt;<br /></code></pre>
    <p>Now let's replace the script containing salesforce controller object and replace it with a mock file:</p> <pre><code>&lt;html&gt;<br />    &lt;body app="myModule"&gt;<br />        &lt;div ng-controller="AController"&gt;<br />            {{ "{{" }}theThing}}<br />        &lt;/div&gt;<br />    &lt;/body&gt;<br />    &lt;script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.2/angular.min.js"&gt;&lt;/script&gt;<br />    &lt;script src="SFDCCtrlMOCK.js'"/&gt;<br />    &lt;script src="AController.js'"/&gt;<br />&lt;/html&gt;<br /></code></pre> <pre><code>//SFDCCtrlMOCK.js<br />(function () {<br />    'use strict';<br />    angular.module('myModule')<br />        .service('SFDCCtrl', SFDCCtrl );<br />        function SFDCCtrl(){<br />            this.MyController = {<br />                doTheThing : doTheThing<br />            }<br /><br />            function doTheThing(){<br />                //return a mock of whatever you expected Salesforce to return you<br />                return 'Athing';<br />            }<br />        }<br />})();<br /></code></pre>
    <p>The Salesforce controller is just an interface now that you or someone else can work on separately from the front end. Now you can work on your page locally! Maintaining these mocks might seem like extra work, but you should probably be building these mocks anyway for Javascript unit testing purposes. Also, the time you save not having to deploy to the server every time you save might even outweigh the cost of building the mock files.</p>
</article>
